///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 20.11.1.1
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
//
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
//
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////

#ifndef __APPLE__
#include "../libpotrace/potracelib.h"
#include <opencv2/opencv.hpp>
#include "function.h"
#include "HalconCpp.h"
#include "HDevThread.h"
using namespace cv;
#else
#ifndef HC_LARGE_IMAGES
#include <HALCONCpp/HalconCpp.h>
#include <HALCONCpp/HDevThread.h>
#include <HALCON/HpThread.h>
#else
#include <HALCONCppxl/HalconCpp.h>
#include <HALCONCppxl/HDevThread.h>
#include <HALCONxl/HpThread.h>
#endif
#include <stdio.h>
#include <CoreFoundation/CFRunLoop.h>
#endif

#ifdef _DEBUG
#pragma comment(lib, "../x64/Debug/libpotrace.lib")
#else
#pragma comment(lib, "../x64/Release/libpotrace.lib")
#endif // DEBUG

using namespace HalconCpp;

#ifndef NO_EXPORT_MAIN
// Main procedure
void action()
{

    // Local iconic variables
    HObject ho_Image, ho_GrayImage, ho_Regions, ho_SelectedRegions;
    HObject ho_EdgeAmplitude, ho_Regions1, ho_OpeningElement;
    HObject ho_RegionOpening, ho_ClosingElement, ho_RegionClosing;
    HObject ho_BinImage;

    // Local control variables
    HTuple hv_Width, hv_Height;

    // Image Acquisition 01: Code generated by Image Acquisition 01
    ReadImage(&ho_Image, //'data/��.jpg'
              "data/\323\300.jpg");
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    Rgb1ToGray(ho_Image, &ho_GrayImage);
    Threshold(ho_GrayImage, &ho_Regions, 6, 142);
    SelectShape(ho_Regions, &ho_SelectedRegions, "area", "and", 0, 31381.5);
    SobelAmp(ho_GrayImage, &ho_EdgeAmplitude, "sum_abs", 3);
    Threshold(ho_EdgeAmplitude, &ho_Regions1, 40, 199);
    GenCircle(&ho_OpeningElement, 0, 0, 2);
    Opening(ho_Regions1, ho_OpeningElement, &ho_RegionOpening);
    GenCircle(&ho_ClosingElement, 0, 0, 2);
    Closing(ho_RegionOpening, ho_ClosingElement, &ho_RegionClosing);
    RegionToBin(ho_RegionClosing, &ho_BinImage, 0, 255, hv_Width, hv_Height);
    WriteImage(ho_BinImage, "bmp", 0, "Edge");
}

#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple gStartMutex;
H_pthread_t gActionThread;
HBOOL gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
    UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
    // Wait until the timer has fired to start processing.
    LockMutex(gStartMutex);
    UnlockMutex(gStartMutex);

    try
    {
        action();
    }
    catch (HException &exception)
    {
        fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
                exception.ProcName().TextA(),
                exception.ErrorMessage().TextA());
    }

    // Tell the main thread to terminate itself.
    LockMutex(gStartMutex);
    gTerminate = TRUE;
    UnlockMutex(gStartMutex);
    CFRunLoopStop(CFRunLoopGetMain());
    return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
    Herror error;
    CFRunLoopTimerRef Timer;
    CFRunLoopTimerContext TimerContext = {0, 0, 0, 0, 0};

    CreateMutex("type", "sleep", &gStartMutex);
    LockMutex(gStartMutex);

    error = HpThreadHandleAlloc(&gActionThread);
    if (H_MSG_OK != error)
    {
        fprintf(stderr, "HpThreadHandleAlloc failed: %d\n", error);
        exit(1);
    }

    error = HpThreadCreate(gActionThread, 0, apple_action);
    if (H_MSG_OK != error)
    {
        fprintf(stderr, "HpThreadCreate failed: %d\n", error);
        exit(1);
    }

    Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                                 CFAbsoluteTimeGetCurrent(), 0, 0, 0,
                                 timer_callback, &TimerContext);
    if (!Timer)
    {
        fprintf(stderr, "CFRunLoopTimerCreate failed\n");
        exit(1);
    }
    CFRunLoopAddTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);

    for (;;)
    {
        HBOOL terminate;

        CFRunLoopRun();

        LockMutex(gStartMutex);
        terminate = gTerminate;
        UnlockMutex(gStartMutex);

        if (terminate)
            break;
    }

    CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);
    CFRelease(Timer);

    error = HpThreadHandleFree(gActionThread);
    if (H_MSG_OK != error)
    {
        fprintf(stderr, "HpThreadHandleFree failed: %d\n", error);
        exit(1);
    }

    ClearMutex(gStartMutex);
    return 0;
}
#endif

int main(int argc, char *argv[])
{
    int ret = 0;

    try
    {
#if defined(_WIN32)
        SetSystem("use_window_thread", "true");
#endif

        // file was stored with local-8-bit encoding
        //   -> set the interface encoding accordingly
        SetHcppInterfaceStringEncodingIsUtf8(false);

        // Default settings used in HDevelop (can be omitted)
        SetSystem("width", 512);
        SetSystem("height", 512);

#ifndef __APPLE__
        // Wrtite here...
        action();
        Mat Edge = imread("Edge.bmp", CV_8UC1);
        // imshow("Edge", Edge);
        // waitKey(0);
        // std::cout << "Edge = " << std::endl << "" << Edge << std::endl << std::endl;
        // std::cout << int(Edge.ptr<uchar>(100)[100]) << std::endl;
        potrace_bitmap_t *bmEdge = bitmapFromMat(Edge, 127);

#else
        ret = apple_main(argc, argv);
#endif
    }
    catch (HException &exception)
    {
        fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
                exception.ProcName().TextA(),
                exception.ErrorMessage().TextA());
        ret = 1;
    }
    return ret;
}

#endif

#endif
